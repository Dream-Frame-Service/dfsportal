{"version":3,"file":"AuthContext-CGZTrpGt.js","sources":["../../src/services/supabaseService.ts","../../src/contexts/AuthContext.tsx"],"sourcesContent":["import { type Database, supabase } from \"@/config/supabase\";\n\n// Generic types for database operations\ntype TableName = keyof Database[\"public\"][\"Tables\"];\ntype TableRow<T extends TableName> = Database[\"public\"][\"Tables\"][T][\"Row\"];\ntype TableInsert<T extends TableName> =\n  Database[\"public\"][\"Tables\"][T][\"Insert\"];\ntype TableUpdate<T extends TableName> =\n  Database[\"public\"][\"Tables\"][T][\"Update\"];\n\n// Helper function to convert table names\nfunction getTableName(table: TableName | symbol): string {\n  return typeof table === \"symbol\" ? String(table) : table;\n}\n\n// Create (Insert)\nexport async function createRecord<T extends TableName>(\n  table: T,\n  data: Partial<Database[\"public\"][\"Tables\"][T][\"Insert\"]>,\n): Promise<Database[\"public\"][\"Tables\"][T][\"Row\"] | null> {\n  const tableName = getTableName(table);\n  const channelName = `${tableName}_${Date.now()}`;\n\n  try {\n    const { data: result, error } = await supabase\n      .from(table)\n      .insert(data as any)\n      .select()\n      .single();\n\n    if (error) {\n      console.error(`Error creating ${tableName}:`, error);\n      return null;\n    }\n\n    return result;\n  } catch (err) {\n    console.error(`Error creating ${tableName}:`, err);\n    return null;\n  }\n}\n\n// Read (Select with pagination)\nexport async function readRecords<T extends TableName>(\n  table: T,\n  options: {\n    page?: number;\n    pageSize?: number;\n    orderBy?: keyof TableRow<T>;\n    ascending?: boolean;\n    filters?: { column: keyof TableRow<T>; operator: string; value: any }[];\n    select?: string;\n  } = {},\n): Promise<{\n  data: TableRow<T>[] | null;\n  count: number | null;\n  error: string | null;\n}> {\n  try {\n    const {\n      page = 1,\n      pageSize = 10,\n      orderBy = \"id\" as keyof TableRow<T>,\n      ascending = false,\n      filters = [],\n      select = \"*\",\n    } = options;\n\n    let query = supabase\n      .from(table)\n      .select(select, { count: \"exact\" });\n\n    // Apply filters\n    filters.forEach((filter) => {\n      const { column, operator, value } = filter;\n      switch (operator.toLowerCase()) {\n        case \"eq\":\n          query = query.eq(column as string, value);\n          break;\n        case \"neq\":\n          query = query.neq(column as string, value);\n          break;\n        case \"gt\":\n          query = query.gt(column as string, value);\n          break;\n        case \"gte\":\n          query = query.gte(column as string, value);\n          break;\n        case \"lt\":\n          query = query.lt(column as string, value);\n          break;\n        case \"lte\":\n          query = query.lte(column as string, value);\n          break;\n        case \"like\":\n          query = query.like(column as string, `%${value}%`);\n          break;\n        case \"ilike\":\n          query = query.ilike(column as string, `%${value}%`);\n          break;\n        default:\n          query = query.eq(column as string, value);\n      }\n    });\n\n    // Apply ordering\n    query = query.order(orderBy as string, { ascending });\n\n    // Apply pagination\n    const from = (page - 1) * pageSize;\n    const to = from + pageSize - 1;\n    query = query.range(from, to);\n\n    const { data, count, error } = await query;\n\n    if (error) {\n      console.error(`Error reading ${table}:`, error);\n      return { data: null, count: null, error: error.message };\n    }\n\n    return { data: (data as unknown) as TableRow<T>[], count, error: null };\n  } catch (err) {\n    console.error(`Error reading ${table}:`, err);\n    return { data: null, count: null, error: \"An unexpected error occurred\" };\n  }\n}\n\n// Update\nexport async function updateRecord<T extends TableName>(\n  table: T,\n  id: number,\n  data: TableUpdate<T>,\n): Promise<{ data: TableRow<T> | null; error: string | null }> {\n  try {\n    const { data: result, error } = await supabase\n      .from(table)\n      .update(data as any)\n      .eq(\"id\", id)\n      .select()\n      .single();\n\n    if (error) {\n      console.error(`Error updating ${table}:`, error);\n      return { data: null, error: error.message };\n    }\n\n    return { data: result, error: null };\n  } catch (err) {\n    console.error(`Error updating ${table}:`, err);\n    return { data: null, error: \"An unexpected error occurred\" };\n  }\n}\n\n// Delete\nexport async function deleteRecord<T extends TableName>(\n  table: T,\n  id: number,\n): Promise<{ error: string | null }> {\n  try {\n    const { error } = await supabase\n      .from(table)\n      .delete()\n      .eq(\"id\", id);\n\n    if (error) {\n      console.error(`Error deleting from ${table}:`, error);\n      return { error: error.message };\n    }\n\n    return { error: null };\n  } catch (err) {\n    console.error(`Error deleting from ${table}:`, err);\n    return { error: \"An unexpected error occurred\" };\n  }\n}\n\n// Batch operations\nexport async function batchCreate<T extends TableName>(\n  table: T,\n  data: TableInsert<T>[],\n): Promise<{ data: TableRow<T>[] | null; error: string | null }> {\n  try {\n    const { data: result, error } = await supabase\n      .from(table)\n      .insert(data as any)\n      .select();\n\n    if (error) {\n      console.error(`Error batch creating ${table}:`, error);\n      return { data: null, error: error.message };\n    }\n\n    return { data: result, error: null };\n  } catch (err) {\n    console.error(`Error batch creating ${table}:`, err);\n    return { data: null, error: \"An unexpected error occurred\" };\n  }\n}\n\nexport async function batchUpdate<T extends TableName>(\n  table: T,\n  updates: { id: number; data: TableUpdate<T> }[],\n): Promise<{ data: TableRow<T>[] | null; error: string | null }> {\n  try {\n    const results = await Promise.all(\n      updates.map(({ id, data }) => updateRecord(table, id, data)),\n    );\n\n    const errors = results.filter((r) => r.error).map((r) => r.error);\n    if (errors.length > 0) {\n      return { data: null, error: errors.join(\", \") };\n    }\n\n    const data = results.map((r) => r.data).filter(Boolean) as TableRow<T>[];\n    return { data, error: null };\n  } catch (err) {\n    console.error(`Error batch updating ${table}:`, err);\n    return { data: null, error: \"An unexpected error occurred\" };\n  }\n}\n\nexport async function batchDelete<T extends TableName>(\n  table: T,\n  ids: number[],\n): Promise<{ error: string | null }> {\n  try {\n    const { error } = await supabase\n      .from(table)\n      .delete()\n      .in(\"id\", ids);\n\n    if (error) {\n      console.error(`Error batch deleting from ${table}:`, error);\n      return { error: error.message };\n    }\n\n    return { error: null };\n  } catch (err) {\n    console.error(`Error batch deleting from ${table}:`, err);\n    return { error: \"An unexpected error occurred\" };\n  }\n}\n\n// File upload\nexport async function uploadFile(\n  bucket: string,\n  path: string,\n  file: File,\n): Promise<{ data: { path: string } | null; error: string | null }> {\n  try {\n    const { data, error } = await supabase.storage\n      .from(bucket)\n      .upload(path, file, {\n        cacheControl: \"3600\",\n        upsert: false,\n      });\n\n    if (error) {\n      console.error(\"Error uploading file:\", error);\n      return { data: null, error: error.message };\n    }\n\n    return { data, error: null };\n  } catch (err) {\n    console.error(\"Error uploading file:\", err);\n    return { data: null, error: \"An unexpected error occurred\" };\n  }\n}\n\n// Get file URL\nexport function getFileUrl(bucket: string, path: string): string {\n  const { data } = supabase.storage\n    .from(bucket)\n    .getPublicUrl(path);\n\n  return data.publicUrl;\n}\n\n// ========================================\n// ENHANCED SERVICE METHODS\n// ========================================\n\n// Email service\nexport class EmailService {\n  static async sendEmail(emailData: {\n    from: string;\n    to: string | string[];\n    subject: string;\n    html: string;\n    text?: string;\n  }): Promise<{ data?: any; error: string | null }> {\n    try {\n      // For now, we'll simulate email sending for development\n      // In production, this would integrate with an email service like Resend, SendGrid, etc.\n      console.log(\"ðŸ“§ Email would be sent:\", {\n        from: emailData.from,\n        to: emailData.to,\n        subject: emailData.subject,\n        preview: `${emailData.html.substring(0, 100)}...`,\n      });\n\n      // You can replace this with actual email service integration\n      // For example, using Supabase Edge Functions:\n      /*\n      const { data, error } = await supabase.functions.invoke('send-email', {\n        body: emailData\n      });\n\n      if (error) {\n        console.error('Email sending error:', error);\n        return { error: error.message };\n      }\n\n      return { data, error: null };\n      */\n\n      // For development, simulate successful email\n      return {\n        data: {\n          message: \"Email logged successfully (development mode)\",\n          emailData,\n        },\n        error: null,\n      };\n    } catch (error) {\n      console.error(\"Error in sendEmail:\", error);\n      return {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      };\n    }\n  }\n}\n\n// Authentication service\nexport class AuthService {\n  static async getCurrentUser() {\n    try {\n      const { data: { user }, error: authError } = await supabase.auth\n        .getUser();\n\n      if (authError || !user) {\n        return {\n          data: null,\n          error: authError?.message || \"User not authenticated\",\n        };\n      }\n\n      const { data: profile, error: profileError } = await supabase\n        .from(\"user_profiles\")\n        .select(\"*\")\n        .eq(\"user_id\", user.id)\n        .single();\n\n      if (profileError) {\n        return {\n          data: {\n            id: user.id,\n            email: user.email,\n            role: \"Employee\",\n            created_at: user.created_at,\n          },\n          error: null,\n        };\n      }\n\n      return {\n        data: {\n          id: user.id,\n          email: user.email,\n          ...profile,\n        },\n        error: null,\n      };\n    } catch (error) {\n      console.error(\"Error in getCurrentUser:\", error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      };\n    }\n  }\n\n  static async register(credentials: { email: string; password: string }) {\n    try {\n      const { data, error } = await supabase.auth.signUp({\n        email: credentials.email,\n        password: credentials.password,\n      });\n\n      if (error) {\n        console.error(\"Supabase registration error:\", error);\n        return { data: null, error: error.message };\n      }\n\n      return { data, error: null };\n    } catch (error) {\n      console.error(\"Error in register:\", error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      };\n    }\n  }\n}\n\n// Helpers so `import { supabase } ...` keeps compiling\nexport { supabase }; // named export\n\n// Lo-fi realtime stub â€“ replace with real manager later.\nexport const realtimeManager = {\n  subscribe: (..._args: any[]) => {/* no-op */},\n  unsubscribe: (..._args: any[]) => {/* no-op */},\n};\n\n// ---------------------------------------------\n// SINGLE service aggregator & default export\n// ---------------------------------------------\nexport const SupabaseService = {\n  createRecord,\n  readRecords,\n  updateRecord,\n  deleteRecord,\n  batchCreate,\n  batchUpdate,\n  batchDelete,\n  uploadFile,\n  getFileUrl,\n  deleteFile,\n  subscribeToChanges,\n  unsubscribeFromChanges,\n  executeRpc,\n  searchRecords,\n};\n\nexport default SupabaseService;\n","import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { toast } from '@/hooks/use-toast';\nimport AuditLoggerService from '@/services/auditLogger';\nimport { supabase } from '@/lib/supabase';\nimport { AuthService } from '@/services/supabaseService';\n\ninterface User {\n  ID: number;\n  Name: string;\n  Email: string;\n  CreateTime: string;\n}\n\ninterface UserProfile {\n  ID: number;\n  user_id: number;\n  role: 'Administrator' | 'Management' | 'Employee';\n  station: string;\n  employee_id: string;\n  phone: string;\n  hire_date: string;\n  is_active: boolean;\n}\n\ninterface AuthContextType {\n  user: User | null;\n  userProfile: UserProfile | null;\n  isAdmin: boolean;\n  login: (email: string, password: string) => Promise<boolean>;\n  logout: () => Promise<void>;\n  register: (email: string, password: string) => Promise<boolean>;\n  loading: boolean;\n  hasPermission: (feature: string, action: 'read' | 'write') => boolean;\n  canEdit: (feature?: string) => boolean;\n  canDelete: (feature?: string) => boolean;\n  canCreate: (feature?: string) => boolean;\n  canViewLogs: (feature?: string) => boolean;\n  isVisualEditingEnabled: boolean;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n// Export the context for use in smart auth hook\nexport { AuthContext };\n\n// Access matrix with monitoring restrictions\nconst ACCESS_MATRIX = {\n  Employee: {\n    dashboard: ['read', 'write'],\n    products: ['read', 'write'],\n    employees: ['read', 'write'],\n    sales: ['read', 'write'],\n    vendors: ['read', 'write'],\n    orders: ['read', 'write'],\n    licenses: ['read', 'write'],\n    monitoring: [] // No monitoring access\n  },\n  Management: {\n    dashboard: ['read', 'write'],\n    products: ['read', 'write'],\n    employees: ['read', 'write'],\n    sales: ['read', 'write'],\n    vendors: ['read', 'write'],\n    orders: ['read', 'write'],\n    licenses: ['read', 'write'],\n    monitoring: [] // No monitoring access\n  },\n  Administrator: {\n    dashboard: ['read', 'write'],\n    products: ['read', 'write'],\n    employees: ['read', 'write'],\n    sales: ['read', 'write'],\n    vendors: ['read', 'write'],\n    orders: ['read', 'write'],\n    licenses: ['read', 'write'],\n    monitoring: ['read', 'write'] // Full monitoring access\n  }\n};\n\nexport const AuthProvider: React.FC<{children: ReactNode;}> = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    checkUserSession();\n  }, []);\n\n  const checkUserSession = async () => {\n    try {\n      const { data, error } = await AuthService.getCurrentUser();\n      if (error) {\n        console.log('No active session');\n        setLoading(false);\n        return;\n      }\n\n      if (data) {\n        // Map Supabase user to legacy User interface\n        const legacyUser: User = {\n          ID: parseInt(data.id) || 0,\n          Name: data.email?.split('@')[0] || '',\n          Email: data.email || '',\n          CreateTime: data.created_at || new Date().toISOString()\n        };\n        setUser(legacyUser);\n        await fetchUserProfile(legacyUser.ID);\n      }\n    } catch (error) {\n      console.error('Session check error:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const fetchUserProfile = async (userId: number) => {\n    try {\n      const { data, error } = await supabase\n        .from('user_profiles')\n        .select('*')\n        .eq('user_id', userId)\n        .single();\n\n      if (error && error.code !== 'PGRST116') { // PGRST116 = no rows found\n        throw error;\n      }\n\n      if (data) {\n        setUserProfile(data);\n      } else {\n        // Create default profile for new users with full access\n        const defaultProfile = {\n          user_id: userId,\n          role: 'Administrator' as const,\n          station: 'ALL',\n          employee_id: `EMP${userId.toString().padStart(4, '0')}`,\n          phone: '',\n          hire_date: new Date().toISOString(),\n          is_active: true\n        };\n\n        const { data: newProfile, error: createError } = await supabase\n          .from('user_profiles')\n          .insert(defaultProfile)\n          .select()\n          .single();\n\n        if (createError) throw createError;\n\n        if (newProfile) {\n          setUserProfile(newProfile);\n        }\n      }\n    } catch (error) {\n      console.error('Error fetching user profile:', error);\n      toast({\n        title: \"Error\",\n        description: \"Failed to load user profile\",\n        variant: \"destructive\"\n      });\n    }\n  };\n\n  const login = async (email: string, password: string): Promise<boolean> => {\n    const auditLogger = AuditLoggerService.getInstance();\n\n    try {\n      setLoading(true);\n      \n      const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password\n      });\n\n      if (error) {\n        // Log failed login attempt\n        await auditLogger.logLogin(email, false, undefined, error.message);\n\n        toast({\n          title: \"Login Failed\",\n          description: error.message,\n          variant: \"destructive\"\n        });\n        return false;\n      }\n\n      // Get user info after successful login\n      const { data: userData, error: userError } = await AuthService.getCurrentUser();\n      if (userError) {\n        await auditLogger.logLogin(email, false, undefined, 'Failed to get user information');\n\n        toast({\n          title: \"Error\",\n          description: \"Failed to get user information\",\n          variant: \"destructive\"\n        });\n        return false;\n      }\n\n      // Map Supabase user to legacy User interface\n      const legacyUser: User = {\n        ID: parseInt(userData.id) || 0,\n        Name: userData.email?.split('@')[0] || '',\n        Email: userData.email || '',\n        CreateTime: userData.created_at || new Date().toISOString()\n      };\n      \n      setUser(legacyUser);\n      await fetchUserProfile(legacyUser.ID);\n\n      // Log successful login\n      await auditLogger.logLogin(email, true, legacyUser.ID);\n\n      toast({\n        title: \"Success\",\n        description: \"Login successful!\"\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Login error:', error);\n      await auditLogger.logLogin(email, false, undefined, 'Unexpected error during login');\n\n      toast({\n        title: \"Error\",\n        description: \"An unexpected error occurred during login\",\n        variant: \"destructive\"\n      });\n      return false;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const register = async (email: string, password: string): Promise<boolean> => {\n    const auditLogger = AuditLoggerService.getInstance();\n\n    try {\n      setLoading(true);\n      \n      const { data, error } = await supabase.auth.signUp({\n        email,\n        password\n      });\n\n      if (error) {\n        // Log failed registration attempt\n        await auditLogger.logRegistration(email, false, error.message);\n\n        toast({\n          title: \"Registration Failed\",\n          description: error.message,\n          variant: \"destructive\"\n        });\n        return false;\n      }\n\n      // Log successful registration\n      await auditLogger.logRegistration(email, true);\n\n      toast({\n        title: \"Registration Successful\",\n        description: \"Please check your email to verify your account.\"\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Registration error:', error);\n      await auditLogger.logRegistration(email, false, 'Unexpected error during registration');\n\n      toast({\n        title: \"Error\",\n        description: \"An unexpected error occurred during registration\",\n        variant: \"destructive\"\n      });\n      return false;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const logout = async () => {\n    const auditLogger = AuditLoggerService.getInstance();\n\n    try {\n      // Log logout before clearing user state\n      if (user) {\n        await auditLogger.logLogout(user.Email, user.ID);\n      }\n\n      await supabase.auth.signOut();\n      setUser(null);\n      setUserProfile(null);\n      toast({\n        title: \"Success\",\n        description: \"Logged out successfully\"\n      });\n    } catch (error) {\n      console.error('Logout error:', error);\n    }\n  };\n\n  const hasPermission = (feature: string, action: 'read' | 'write'): boolean => {\n    if (!userProfile) return false;\n\n    // Special handling for monitoring features\n    if (feature === 'monitoring') {\n      return userProfile.role === 'Administrator';\n    }\n\n    // Full access for all other features\n    return true;\n  };\n\n  const canEdit = (feature?: string): boolean => {\n    if (!userProfile) return false;\n\n    // Monitoring features restricted to Administrators\n    if (feature === 'monitoring') {\n      return userProfile.role === 'Administrator';\n    }\n\n    // Full visual editing access for all users and other features\n    return true;\n  };\n\n  const canDelete = (feature?: string): boolean => {\n    if (!userProfile) return false;\n\n    // Monitoring features restricted to Administrators\n    if (feature === 'monitoring') {\n      return userProfile.role === 'Administrator';\n    }\n\n    // Full delete access for all users and other features\n    return true;\n  };\n\n  const canCreate = (feature?: string): boolean => {\n    if (!userProfile) return false;\n\n    // Monitoring features restricted to Administrators\n    if (feature === 'monitoring') {\n      return userProfile.role === 'Administrator';\n    }\n\n    // Full create access for all users and other features\n    return true;\n  };\n\n  const canViewLogs = (feature?: string): boolean => {\n    if (!userProfile) return false;\n\n    // Monitoring features restricted to Administrators\n    if (feature === 'monitoring') {\n      return userProfile.role === 'Administrator';\n    }\n\n    // Full log viewing access for all users and other features\n    return true;\n  };\n\n  const isVisualEditingEnabled = true;\n  const isAdmin = userProfile?.role === 'Administrator';\n\n  const value = {\n    user,\n    userProfile,\n    isAdmin,\n    login,\n    logout,\n    register,\n    loading,\n    hasPermission,\n    canEdit,\n    canDelete,\n    canCreate,\n    canViewLogs,\n    isVisualEditingEnabled\n  };\n\n  return (\n    <AuthContext.Provider value={value} data-id=\"8nhyy6fc8\" data-path=\"src/contexts/AuthContext.tsx\">\n      {children}\n    </AuthContext.Provider>);\n\n};\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n"],"names":["data","createContext","useContext"],"mappings":"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"}